8.Kotlin_协程
===

Kotlin引入了协程（Coroutine）来支持更好的异步操作，利用它我们可以避免在异步编程中使用大量的回调，同时相比传统多线程技术，它更容易提升系统的高并发处理能力。 

一些`API`启动长时间运行的操作(例如网络`IO`、文件`IO`、`CPU`或`GPU`密集型任务等)，并要求调用者阻塞直到它们完成。协程提供了一种避免阻塞线程
并用更廉价、更可控的操作替代线程阻塞的方法:协程挂起。     
协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、
订阅相关事件、在不同线程(甚至不同机器！)上调度执行，而代码则保持如同顺序执行一样简单。     



### 起源

协程是一个无优先级的子程序调用组件，允许子程序在特定的地方挂起恢复。线程包含于进程，协程包含于线程。只要内存足够，一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。

线程是由操作系统来进行调度的，当操作系统切换线程的时候，会产生一定的消耗。而协程不一样，协程是包含于线程的，也就是说协程是工作在线程之上的，协程的切换可以由程序自己来控制，不需要操作系统进行调度。这样的话就大大降低了开销。




### 阻塞 vs 挂起

基本上，协程计算可以被挂起而无需阻塞线程。线程阻塞的代价通常是昂贵的，尤其在高负载时，因为只有相对少量线程实际可用，因此阻塞其中一个会导致一些
重要的任务被延迟。

另一方面，协程挂起几乎是无代价的。不需要上下文切换或者`OS`的任何其他干预。最重要的是，挂起可以在很大程度上由用户库控制:   
作为库的作者，我们可以决定挂起时发生什么并根据需求优化/记日志/截获。

另一个区别是，协程不能在随机的指令中挂起，而只能在所谓的挂起点挂起，这会调用特别标记的函数。

#### 挂起函数    

当我们调用标记有特殊修饰符`suspend`的函数时，会发生挂起:    

```kotlin
suspend fun doSomething(foo: Foo): Bar {
    ……
}
```

这样的函数称为挂起函数，因为调用它们可能挂起协程(如果相关调用的结果已经可用，库可以决定继续进行而不挂起)。挂起函数能够以与普通函数相同的方式
获取参数和返回值，但它们只能从协程和其他挂起函数中调用。事实上，要启动协程，
必须至少有一个挂起函数，它通常是匿名的(即它是一个挂起`lambda`表达式)。让我们来看一个例子，一个简化的`async()`函数
(源自`kotlinx.coroutines`库):    

```kotlin
fun <T> async(block: suspend () -> T)
```

这里的`async()`是一个普通函数(不是挂起函数)，但是它的`block`参数具有一个带`suspend`修饰符的函数类型:`suspend() -> T`。
所以，当我们将一个`lambda`表达式传给`async()`时，它会是挂起`lambda`表达式，于是我们可以从中调用挂起函数:    

```kotlin
async {
    doSomething(foo)
    ……
}
```

继续该类比,`await()`可以是一个挂起函数(因此也可以在一个`async {}`块中调用)，该函数挂起一个协程，直到一些计算完成并返回其结果:   
```kotlin
async {
    ……
    val result = computation.await()
    ……
}

```

更多关于`async/await`函数实际在`kotlinx.coroutines`中如何工作的信息可以在这里找到。

请注意，挂起函数`await()`和`doSomething()`不能在像`main()`这样的普通函数中调用:    
```kotlin
fun main(args: Array<String>) {
    doSomething() // 错误：挂起函数从非协程上下文调用
}
```

还要注意的是，挂起函数可以是虚拟的，当覆盖它们时，必须指定`suspend`修饰符:    
```kotlin
interface Base {
    suspend fun foo()
}

class Derived: Base {
    override suspend fun foo() { …… }
}
```




---

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 



# 1.操作系统简介



操作系统(Operating System, 简称OS)是管理和控制计算机硬件与软件资源的计算机程序，是一种由引导程序（bootloader）启动并管理计算机中所有程序生命周期的系统程序。任何其他软件都必须在操作系统的支持下才能运行，操作系统能有效组织和管理系统中的各种软、硬件资源，合理组织计算机系统的工作流程并控制程序的执行，为用户提供一个良好的操作环境。 目前比较为人所知的操作系统有Microsoft的Windows系统、Apple的Mac及以Linux为内核的各种Linux发行版(Centos/Ubuntu等)。 现代计算机系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口及各种输入\输出设备构成。

作用:    它可以帮我们管理计算机的各种资源，协助我们完成各种复杂繁琐的任务。



操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型

- 文件：对 I/O 设备的抽象
- 虚拟内存：对程序存储器的抽象
- 进程：对一个正在运行程序的抽象
- 虚拟机：对整个操作系统的抽象



### 以现代标准而言，一个标准PC的操作系统应该提供以下功能



### 用户界面(User interface)



普通用户操作电脑是需要用户界面的，没有用户界面的电脑对于普通用户来说就是灾难。你能想象家里的老人或者上了年纪的人用电脑却没有鼠标的场景吗？你能想象使用黑框框来做 PPT 吗？你能想象使用黑框框来浏览网页吗？
专业的 IT 工作者有时候会使用黑框框纯粹是工作需要，在有些场景下，黑框框比用户界面更有效率一些。而类似于服务器场景的开发工作基本上是没有用户界面的，当然一直强调的是专业场景，这个世界上能流畅使用黑框框的人占总人口的比例太少太少。
用户界面这项伟大的发明诞生于施乐公司，经乔布斯和比尔盖茨商业化运作后得以让世人发现它的伟大之处。用户界面的发明就相当于简体汉字的出现一般，简体汉字的推行让中国的文盲率大幅降低，而用户界面的发明则大幅降低了计算机的使用难度，所以你很难想象现代的操作系统没有用户界面。



#### 进程管理(Processing management)



先来解释一下什么是进程。进程是计算机进行资源管理以及调度的基本单位，是程序的执行实体。这种说法比较正统，或者你可以将一个进程看成是计算机正在进行的一项任务。计算机里面有很多各式各样功能的进程，那么多进程如何比较好的运行是个深奥的学问。
你可以想象一下：你打开了微信、word 文档、音乐软件，你想一边跟同事进行交流文档的内容应该如何写，一边在 word  文档敲下你的构思，然后在这个过程中你还听着音乐。在这个过程中，计算机需要将微信的网络保持连接，持续收发微信的信息，随时保存你的 word  文档到磁盘上，解码音乐流并播放出来。这一系列程序运转如何能让你产生一个假象：你以为它们是在同时运行的，但其实它们在同一时刻只有一个在运行。这就是进程管理和调度。



#### 内存管理(Memory management)

内存是计算机很重要的一个资源，因为程序只有被加载到内存中才可以运行，此外 CPU  所需要的指令与数据也都是来自内存的。内存的并不是无限制的，它受限于硬件和寻址位数。但是现代操作系统会让每一个进程都觉得自己在独占整个内存，这就是虚拟内存技术。值得注意的是，这里的虚拟内存与 swap 这种虚拟内存是不一样的，虽然两个都是称为虚拟内存，但是完全是两个不同方向的技术。
进程的运行需要分配内存，内存分配的快慢都与内存管理方式有着巨大的影响。两个不同进程对应的内存区域是不能相互访问的，操作系统必须得提供这样的保证，否则很容易出问题，比如：运行着的 dota  游戏如果可以被另外一个进程访问它的内存区域的话，那就可以直接将内存区域中的某个数值进行修改，比如将游戏中的玩家生命值变为无限，这样对手怎么打都打不死自己的英雄。例如前段时间火热的吃鸡游戏，外挂软件可以让角色在决赛圈外进行锁血，这个就是游戏内存被修改的最好示例。当然这是通过比较专业的手段来绕过操作系统的限制，这也从另外一个方面来说明，其实现在的操作系统安全性也是有很大提升空间的。
进程退出销毁时，内存的回收也是很重要的，否则很容易就会产生内存溢出，占着茅坑不拉屎，导致其他的进程都憋死。



#### 文件系统(File system)



文件系统与用户的距离很近，每个人平常在使用计算机的时候或多或少都会留下一些数据，而这些数据通常会保留在磁盘里面。磁盘如果不进行格式化的话，普通人是没法使用的。磁盘里面其实就是一些布满磁性物质的盘片，在计算机的世界里数据是 0 和 1 组成的，那对应的在磁盘里面就是磁性的正负极，也就是说计算机的一个文本数据要保存到磁盘中，那就需要将文本数据的电气化信号 0 和 1 通过磁盘翻译为磁性正负极并保存起来。
磁盘格式化的过程就是将文件系统架设到磁盘上，这样可以更好的管理磁盘的数据。你可以将磁盘未格式化之前的数据看做是一堆杂乱无章散落在地上的书，而文件系统就是一个有编排顺序的书架，格式化的过程就是将这堆书一本本按编排顺序放到书架上。这个比喻不太恰当，因为格化式操作通常来说会清掉数据，就相当于将书里面的字都清掉了，放到书架上的书里面都是空白页，所以格式化的时候请谨慎。



#### 网络通信(Networking)



我们常见的网络通信场景有：微信聊天、浏览网页、玩网络游戏等，可以说现在的操作系统如果不能上网感觉就没了灵魂。网络通信是个很复杂的过程，连很多专业的程序猿都说不清楚当他上网时网页是如何显示出来的，更别说整个网络的拓扑结构了。
整个网络通信其实是一套约定好的通信协议，很多人第一次听说协议时觉得很高级，其实没什么高级的，简单的说，类似于我们军训时当教官喊立正我们必须得做出相应动作一样，一个指令对应一个动作。由于网络太复杂了，某位哲人说过如果某样东西太复杂可以通过分层来解决，于是网络分了 5 层。有人也许会说是 7 层，那是 OSI 标准，在实际应用中一般都是 5 层。



#### 设备管理



计算机上有很多设备，比如CPU、内存、网卡、声卡、显卡、硬盘等。那什么是设备管理？
在计算机中除了 CPU 和内存，对于其他一切输入输出设备的管理统称为设备管理。
计算机中的设备分为输入和输出设备。以 CPU 为中心，凡是向 CPU 输送数据的设备统称为输入设备，例如鼠标、键盘、摄像头等；同样以 CPU 为中心，凡是从 CPU 获取数据的设备统称为输出设备，如显示器等。有些设备既是输入设备也是输入设备，比如网卡等。 
一个比较常见的场景是当我们将 U盘插进电脑的 USB 插孔时，电脑能实时识别出 U 盘设备，那计算机为啥能实时识别出这些设备呢？之后会有章节讨论一下这个话题。



## 计算机的组成



计算机由处理器、存储器和输入/输出部件组成，每类部件都有一个或多个模块。这些部件以某种方式互连，以实现计算机执行程序的主要功能。因此，计算机有4个主要的结构化部件: 

- 处理器(Processor)：控制计算机的操作，执行数据处理功能。只有一个处理器时，它通常指中央处理器(CPU).
- 内存（Main memory):存储数据和程序。此类存储器通常是易失性的，即当计算机关机时，存储器的内容会丢失。相对于此的是磁盘存储器，当计算机关机时，它的内容不会丢失。内存通常也称为实存储器(real memory)或主存储器(primary memory)。
- 输入/输出模块(I/O modules):在计算机和外部环境之间移动数据。外部环境由各种外部设备组成，包括辅助存储器设备(如硬盘)、通信设备和终端。
- 系统总线(System bus):在处理器、内存和输入/输出模块间提供通信的设施。 



处理器的一种功能是与存储器交换数据。为此，它通常使用两个内部寄存器: 

- 存储器地址寄存器(Memory Address Register, MAR),用于确定下一次读/写的存储器地址。
- 存储器缓冲寄存器(Memory Buffer Register,MBR),存放要写入存储器的数据或从存储器中读取的数据。

同理，输入/输出地址存储器(I/O Address Register，简称I/O AR或I/O地址寄存器)用于确定一个特定的输入/输出设备，输入/输出缓冲寄存器(I/O Buffer Register，简称I/O BR或I/O缓冲寄存器)用于在输入/输出模块和处理器间交换数据。 



内存模块由一组单元组成，这些单元由顺序编号的地址定义。每个单元包含一个二进制数，它可解释为一个指令或数据。输入/输出模块在外部设备与处理器和存储器之间传送数据。输入/输出模块包含内存缓冲区，用于临时保存数据，直到它们被发送出去。

![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/computer_cpu_memory_io.png?raw=true)



### 计算机打开电源后的执行

在每台计算机上有一块双亲板（在政治因素影响到计算机产业之前，它们曾称为“母版”）。在双亲板上有一个称为基本输入输出系统（Basic Input Output System， BIOS）的程序。在BIOS内有底层I/O软件，包括读键盘、写屏幕、进行磁盘I/O以及其他过程。在计算机启动时，BIOS开始运行。它首先检查所安装的RAM数量、键盘和其他基本设备是否已安装并正常响应。接着，它开始扫描PCIe和PCI总线并找出连在上面的所有设备。即插即用设备也被记录下来。如果现有的设备和系统上一次启动时的设备不同，则新的设备将被配置。然后BIOS通过尝试存储在CMOS存储器中的设备清单决定启动设备。用户可以在系统刚启动之后进入一个BIOS配置程序，对设备清单进行修改。典型的，如果存在CD-ROM（有时是USB），则系统试图从中启动（之前重装系统就是这么操作的）。如果失败，系统将从硬盘启动。启动设备上的第一个扇区被读入内存并执行。这个扇区中包含一个对保存在启动扇区末尾的分区表检查的程序，以确定哪个分区是活动的。然后，从该分区读入第二个启动装载模块。来自活动分区的这个装载模块被读入操作系统，并启动之。 

然后，操作系统询问BIOS，以获得配置信息。对于每种设备，系统检查对应的设备驱动程序是否存在。如果没有，系统要求用户插入含有该驱动程序的CD-ROM（由设备供应商提供）或者从网络上下载驱动程序。一旦有了全部的设备驱动程序，操作系统就将它们调入内核。然后初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登陆程序或GUI。



不同的处理器和硬解系统可能会采用不同的策略，但是通用系统的启动分为三个步骤: 

- 开机并执行bootloader程序

    开机就是给系统开始供电，此时硬件电路会产生一个确定的复位时序，保证CPU是最后一个被复位的器件。为什么CPU要最后被复位呢？ 因为，如果CPU是第一个被复位，则当CPU复位后开始运行时，其他硬件内部的寄存器状态可能还没有准备好，比如磁盘或者内存，那这样就可能出现外围硬件初始化的错误。当正确完成复位后，CPU开始执行第一条指令，该指令所在的内存地址是固定的，这由CPU的制造者指定。不同的CPU可能会从不同的地址获取指令，但这个地址必须是固定的，这个固定的地址所保存的程序往往被称为“引导程序“（Bootloader），因为其作用是装载真正的用户程序。

    至于如何装载，则是一个策略问题，不同的CPU会提供不同的装载方式，比如有的是通过普通的并口存储器，有的则是通过SD卡，但是无论硬件上使用何种接口装载，装载过程必须提供以下信息，具体包括： 

    - 从哪里读取用户程序？
    - 用户程序的长度是多少？
    - 装载完用户程序后，应该跳转到哪里，即用户程序的执行入口在哪里？

- 操作系统内核初始化

    执行内核程序，这一步所说的内核程序在上一步中指的就是”用户程序“。因为从CPU的角度来看，除了Bootloader之外的所有程序都是用户程序，只是从软件的角度来看，用户程序被分为”内核程序“和”应用程序“，而本步执行的是内核程序。

    内核程序初始化时执行的操作包括，初始化各种硬件，包括内存、网络接口、显示器、输入设备、然后建立各种内部数据结构，这些数据结构将用于多线程调度及内存的管理等。当内核初始化完毕后就开始运行具体的应用程序了。在一般情况下，习惯于将第一个应用程序称为”Home程序“。

- 执行第一个应用程序

    运行Home程序，比如Windows系统的桌面。之所以称为Home程序，是因为通过该程序可以方便的启动其他应用程序。而传统的Linux系统启动后第一个运行的程序一般是一个Terminal。



### Android系统启动过程

目前的Android系统大多运行在ARM处理器之上。ARM本身是一个公司的名称，从技术的角度来看，它又是一种微处理器内核的架构。

对于ARM处理器，当复位完毕后，处理器首先还行其片上ROM中的一小块程序。这块ROM的大小一般只有几KB，该段程序就是Bootloader程序，这段程序执行时会根据处理器上一些特定引脚的高低电平状态，选择从何种物理接口上装载用户程序，比如USB口、SD卡、并口Flash等。

多数基于ARM的实际硬件系统，会从并口NAND Flash芯片上的0x00000000地址处装载程序。对于一些小型嵌入式系统而言，该地址中的程序就是最终要执行的用户程序；而对于Android而言，该地址中的程序还不是Android程序，而是一个叫做uboot或者fastboot的程序，其作用是初始化硬件设备，比如网口、SDRAM、RS232等，并提供一些调试功能，比如向NAND Flash中写入新的数据，这可用于开发过程中的内核烧写、升级等。

当uboot（fastboot）被装载后便开始运行，它一般会先检测用户是否按下了某些特别的按键，这些特别按键是uboot在编译时预先预定好的，用于进入调试模式。如果用户没有按这些特殊的按键，则uboot会从NAND Flash中装载Linux内核，装载的地址是在编译uboot时预先约定好的。

Linux内核被装载后，就开始进行内核初始化的过程。

![](https://raw.githubusercontent.com/CharonChui/Pictures/master/android_power_on_start.png)



![](https://raw.githubusercontent.com/CharonChui/Pictures/master/android_system_start.png)

- Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在`ROM`里的预设代码开始执行，然后加载引导程序到`RAM`；
- Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。

Android平台的基础是Linux内核，比如ART虚拟机最终调用底层Linux内核来执行功能。Linux内核的安全机制为Android提供相应的保障，也允许设备制造商为内核开发硬件驱动程序。

- 启动Kernel的swapper进程(pid=0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作；
- 启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。`kthreadd进程是所有内核进程的鼻祖`。

这里的Native系统库主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，`init进程是所有用户进程的鼻祖`。

- init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；
- init进程还启动`servicemanager`(binder服务管家)、`bootanim`(开机动画)等重要服务
- init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，`Zygote是所有Java进程的父进程`，Zygote进程本身是由init进程孵化而来的。

- Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含：
    - 加载ZygoteInit类，注册Zygote Socket服务端套接字
    - 加载虚拟机
    - 提前加载类preloadClasses
    - 提前加载资源preloadResouces
- System Server进程，是由Zygote进程fork而来，`System Server是Zygote孵化的第一个进程`，System Server负责启动和管理整个Java framework，包含ActivityManager，WindowManager，PackageManager，PowerManager等服务。
- Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。
- Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App；
- Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。
- 所有的App进程都是由Zygote进程fork生成的。

 

## CPU(Central Processing Unit)

CPU(中央处理器)是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。它是一块超大规模的集成电路(Integrated Circuit)，是信息处理、程序运行的最终执行单元。其功能主要是解释计算机指令以及处理计算机软件中的数据。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些寄存器来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。从功能方面来看，CPU的内部主要由寄存器，控制器，运算器构成，各部分之间由电流信号相互连通。其中运算器负责算术运算和逻辑运算，控制器负责计算指令的解析，产生各种控制指令，寄存器组用来临时存放参加运算的数据和计算的中间结果。CPU计算结果最终需要写到内存中，内存的存取速度远低于CPU，为提升数据交换速率，CPU内部一般还集成了高速缓存（CACHE）,其中缓存分为一级缓存和二级缓存，一级缓存和CPU速率相当，二级缓存次之。



CPU 主要由两部分构成：`控制单元` 和 `算术逻辑单元（ALU）`

- 控制单元：从内存中提取指令并解码执行
- 算数逻辑单元（ALU）：处理算数和逻辑运算

CPU 是计算机的心脏和大脑，它和内存都是由许多晶体管组成的电子部件。它接收数据输入，执行指令并处理信息。它与输入/输出（I / O）设备进行通信，这些设备向 CPU 发送数据和从 CPU 接收数据。

CPU 的内部由**寄存器、控制器、运算器和时钟**四部分组成，各部分之间通过电信号连通。

- `寄存器`是中央处理器内的组成部分。它们可以用来暂存指令、数据和地址。可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有 20 - 100个寄存器。
- `控制器`负责把内存上的指令、数据读入寄存器，并根据指令的结果控制计算机
- `运算器`负责运算从内存中读入寄存器的数据
- `时钟` 负责发出 CPU 开始计时的时钟信号



**程序是把寄存器作为对象来描述的**

使用高级语言编写的程序会在编译后转化成机器语言，然后通过CPU内部的寄存器来处理。不同类型的CPU，其内部寄存器的数量，种类以及寄存器存储的数值范围都是不同的。根据功能的不同，我们可以将寄存器大致划分为八类: 

- ***累加寄存器简称累加器(Accumulator， AC)***：是一个通用寄存器。存储临时的执行运算的数据和运算后的数据。
- ***标志寄存器***：存储运算处理后的CPU的状态。
- ***程序计数器(Program Counter, PC)***：记录将要取出的指令的地址。存储下一条指令所在内存的地址。
- ***基址寄存器***：存储数据内存的起始地址。
- ***变址寄存器***：存储基址寄存器的相对地址。
- ***通用寄存器***：存储任意数据。
- ***指令寄存器(Instruction Register, IR)***：记录最近取出的指令。存储指令，CPU取到的指令存放在处理器的一个寄存器中，这个寄存器就是指令寄存器。CPU内部使用，程序员无法通过程序对该寄存器进行读写操作。
- ***堆栈寄存器(stack pointer)***：目的是跟踪调用堆栈，存储栈区域的起始地址。指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。
- **程序状态字寄存器(PSW(Program Status Word))**：这个寄存器是由操作系统维护的8个字节(64位) long 类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略 PSW 。用户程序通常可以读取整个PSW，但通常只能写入其某些字段。PSW 在系统调用和 I / O 中起着重要作用。

其中，程序计数器，累加寄存器，标志寄存器，指令寄存器和栈寄存器都只有一个，其他的寄存器一般有多个。



***计算机执行的原理是: 取指执行***

处理器执行的程序是由一组保存在存储器中的指令组成的。最简单的指令处理包括两步: 处理器从存储器中一次读(取)一条指令，然后执行每条指令。程序执行是由不断重复的取指令和执行指令的过程组成的。指令执行可能涉及很多操作，具体取决于指令本身。 

在典型的处理器中，程序计数器(Program Counter, PC)保存下一次要取的指令地址。除非出现其它情况，否则处理器在每次取值令后总是递增PC，以便能按顺序取下一条指令(即位于下一个存储器地址的指令)。取到的指令放在处理器的一个寄存器中，这个寄存器称为指令寄存器(Instruction Register,IR)。指令中包含确定处理器将要执行的操作的位，处理器解释指令并执行对应的操作。大体上，这些动作可分为4类:  

- 处理器-存储器:数据可以从处理器传送到存储器，或从存储器传送到处理器。
- 处理器-I/O:通过处理器和I/O模块间的数据传送，数据可以输出到外部设备，或从外部设备向处理器输入数据。
- 数据处理:处理器可以执行很多与数据相关的算术操作或逻辑操作。
- 控制: 某些指令可以改变执行顺序。例如，处理器从地址为149的存储单元中取出一条指令，该指令指向下一条指令应该从地址为182的存储单元中取，这样处理器就会把程序计数器置为182.因此在下一个取指阶段，将从地址182的存储单元而非150的存储单元中取指令。 



## CPU 指令执行过程

那么CPU是如何执行一条条的指令的呢？

几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为5个阶段：**取指令、指令译码、执行指令、访存取数、结果写回**。

- 取指令阶段是将内存中的指令读取到CPU中寄存器的过程，程序寄存器用于存储下一条指令所在的地址
- 指令译码阶段，在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。
- 执行指令阶段，译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。
- 访问取数阶段，根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。
- 结果写回阶段，作为最后一个阶段，结果写回（Write Back，WB）阶段把执行指令阶段的运行结果数据“写回”到某种存储形式：结果数据经常被写到CPU的内部寄存器中，以便被后续的指令快速地存取；



假设目前一台机器的处理器包含一个累加器(AC)的数据寄存器，所有指令和数据长度均为16位，使用16位的单元或字来组织存储器。指令格式中有4位是操作码。操作码定义了处理器执行的操作。通过指令格式剩下的12位，来直接访问存储器。

![](https://raw.githubusercontent.com/CharonChui/Pictures/master/cpu_zhiling_1.png)

如上图中的三个指令中的操作码描述了要执行的操作。

下图描述了程序的执行过程。给出的程序片段把地址为940的存储单元中的内容与地址为941的存储单元的内容相加，并将结果保存在后一个单元中。这需要三条指令。 

![](https://raw.githubusercontent.com/CharonChui/Pictures/master/cpu_process_demo.png)

该图中，为把地址为940的存储单元中的内容与地址为941的存储单元中的内容相加，一共需要三个指令周期，每个指令周期都包含一个取指阶段和一个执行阶段。具体步骤为 ： 

1. PC中包含第一条指令的地址为300，该指令内容（值为十六进制数1940）被送入指令寄存器IR中，PC增加1。注意，该处理过程中使用了存储器地址寄存器(MAR)和存储器缓冲寄存器（MBR）。为简单起见，这里未显示这些中间寄存器。
2. IR中取出操作码，也就是最初的4位（对应到这里的十六进制，就是第一位数也就是1），而在上面1对应的二进制操作码是0001 = 从内存中载入AC。剩下的12位（后三个十六进制数）表示的是地址为940。所以这里的意思就是将存储器940地址的单元加载到AC中。
3. 然后继续去下一条指令，PC现在是301了，所以要从地址为301的存储单元中取下一条指令，也就是(5941)，同时PC增加1。这条指令是5941，最初的4位操作码是5，对应的二进制是0101，上面的操作码图标中0101 = 从内存中添加到AC。剩下的12位（后三个十六进制数）表示的是地址为941。
4. 内存地址为941的存储单元中的内容与AC中以前的内容相加，结果保存在AC中。
5. 接着读下一个指令，现在PC是302了，从302的存储单元中读取下一个指令为2941，PC同时加1.前四位操作码对应的是2，转换成二进制也就是0010 = 将AC存储到内存。后十二位对应的地址是941。所以这条指令的意思就是将AC中的内容存储到地址为941的存储单元中。
6. 执行指令，将AC中的内容存储到地址为941的存储单元中。现在941存储单元的内容变成了5.



#### 操作系统的两种CPU状态

- 内核态(Kernel Mode):运行操作系统程序
- 用户态(User Mode):运行用户程序

操作系统只需要这两种状态，同时这两种状态由对应的两种指令: 

- 特权(privilege)指令:只能由操作系统使用、用户程序不能使用的指令
- 非特权指令:用户程序可以使用的指令

用户态 -> 内核态的唯一途径是通过中断/异常/陷入机制。

内核态 -> 用户态是通过设置程序状态字PSW。

一旦 CPU 决定去实施中断后，程序计数器和 PSW 就会被压入到当前堆栈中并且 CPU 会切换到内核态。设备编号可以作为内存的一个引用，用来寻找该设备中断处理程序的地址。这部分内存称作`中断向量(interrupt vector)`。一旦中断处理程序（中断设备的设备驱动程序的一部分）开始后，它会移除栈中的程序计数器和 PSW 寄存器，并把它们进行保存，然后查询设备的状态。在中断处理程序全部完成后，它会返回到先前用户程序尚未执行的第一条指令。

### 中断/异常

可以说操作系统是由“中断驱动”或者“时间驱动”的。中断/异常是CPU对系统发生的某个事件作出的一种反应。

所有计算机都提供了允许其他模块（I/O、存储器)中断处理器正常处理过程的机制。中断最初是用于提高处理器效率的一种手段。例如，多数I/O设备都要远慢于处理器，处理器必须暂停并保持空闲，直到打印机完成工作。暂停的时间长度可能相当于成百上千个不涉及存储器的指令周期，显然，这对于处理器的使用来说是非常浪费的。这种只有一个单独程序的情况，称为单道程序设计。在单道程序设计中处理器话费一定的运行时间进行计算，直到遇到一个I/O指令，这时它必须等到该I/O指令结束后才能继续执行。这种问题是可以避免的，就是存储器可以保存多个程序，在一个程序等待时通过切换去执行其他的程序，这种处理称为多道程序设计或多任务处理。它是现代操作系统的主要方案。多道程序设计的目的是为了让处理器和I/O设备（包括存储设备）同时保持忙状态，以实现最大的效率。



利用中断功能，处理器可以在I/O操作的执行过程中去执行其他命令。在这期间，如果I/O操作已经完成，此时外部设备在做好服务的准备后，即它准备好从处理器接收更多的数据时，外部设备的I/O模块给处理器发送一个中断请求信号。这时处理器会做出响应，暂停当前程序的处理，转去处理服务于特定I/O设备的程序，这种程序被称为中断处理程序(interupt handler)。在对该设备的服务响应完成后，处理器恢复原来的执行。

从用户程序的角度来看，中断打断了正常执行的序列。中断处理完成后，再恢复执行。因此，用户程序并不需要为中断添加任何特殊的代码，处理器和操作系统负责挂起用户程序，然后在同一个地方恢复执行。

为使用中断产生的情况，在指令周期中要增加一个中断阶段。在中断阶段，处理器检查是否有中断发生，即检查是否出现中断信号。若没有中断，处理器继续运行，并在取指周期取当前程序的下一条指令。若有中断，处理器挂起当前程序的执行，并执行一个中断处理程序。这个中断处理程序通常是操作系统的一部分，它确定中断的性质，并执行所需要的操作。

![](https://raw.githubusercontent.com/CharonChui/Pictures/master/cpu_zhiling_intercept.png)



### 举个栗子

- 中断

    有一天我正在看书的时候，来电话了，这时候我需要执行中断，我会把当前看到的书的进度用书签标记，然后去接电话，等电话接完后，再返回从书签的位置继续读书。

- 异常

    同样我在读书，但是由于新买的书纸张太硬，一不小心把手划破流血了，那这个时候就是异常，我同样需要把当前看到的书的进度用书签标记，然后去用创可贴来处理伤口，等处理完后再返回书签的位置继续读书。





### 中断/异常机制工作原理

硬件和软件相互配合而使计算机系统得以充分发挥能力。

- 硬件的作用 -- 中断/异常响应

    捕获中断源发出的中断/异常请求，以一定方式响应，将处理器控制权交给特定的处理程序。发现中断、接受中断都是由硬件来完成。

- 软件的作用 -- 中断/异常处理程序

    识别中断/异常类型并完成相应的处理。





### 中断处理

当I/O设备完成一次I/O操作时，发生以下硬件事件:  

1. 设备给处理器发送一个中断信号。
2. 处理器在响应中断前结束当前指令的执行。
3. 处理器对中断进行测试，确定存在未响应的中断，并给提交中断的设备发送确认信号，确认信号允许该设备取消它的中断信号。
4. 处理器需要准备把控制权转交给中断程序。首先，需要保存从中断点恢复当前程序所需要的信息，要求的最少信息包括程序状态字（PSW）和保存在程序计数器（PC）中的下一条要执行的指令地址，它们被压入系统控制栈。
5. 处理器把响应此中断的中断处理程序入口地址装入程序计数器。每类中断可由一个中断处理程序，具体取决于计算机系统架构和操作系统的设计。如果有多个中断程序，这一信息可能已包含在最初的中断信号中，否则处理器必须给发中断的设备发送请求，以获取含有所需信息的响应。一旦装入程序计数器，处理器就继续执行下一个指令周期，该指令周期也从取指开始。由于取指是由程序计数器的内容决定的，因此控制权被转交给中断处理程序，该程序会引起以下操作： 
6. 在这一点，与被中断程序相关的程序计数器和PSW被保存到系统栈中，此外，还有一些其他信息被当做正在执行程序的状态的一部分。特别需要保存处理器寄存器的内容，因为中断处理程序可能会用到这些寄存器，因此所有这些值和任何其他状态信息都需要保存。
7. 中断处理程序现在可以开始处理中断，其中包括检查与I/O操作相关的状态信息或其他引起中断的事件，还可能包括给I/O设备发送附加命令或应答。
8. 中断处理结束后，被保存的寄存器值从栈中释放并恢复到寄存器中。
9. 最后的操作是从栈中恢复PSW和程序计数器的值，因此下一条要执行的指令来自前面被中断的程序。



与每一 I/O 类相关联的是一个称作 `中断向量(interrupt vector)` 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程 3 正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。

当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程。

1. 硬件压入堆栈程序计数器等
2. 硬件从中断向量装入新的程序计数器
3. 汇编语言过程保存寄存器的值
4. 汇编语言过程设置新的堆栈
5. C 中断服务器运行（典型的读和缓存写入）
6. 调度器决定下面哪个程序先运行
7. C 过程返回至汇编代码
8. 汇编语言过程开始运行新的当前进程

一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。



## 存储器

在任何一种计算机中，第二种主要部件都是存储器。在理想情况下，存储器应该极为迅速（快于执行一条指令，这样CPU就不会受到存储器的限制），充分大并且非常便宜。但是目前的技术无法同时满足这三个目标。

- 存取时间越快，每“位”的价格越高
- 容量越大，每“位”的价格越低
- 容量越大，存取速度越慢



![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/computer_storage_type.png?raw=true)

于是出现了多级存储器组织结构:

- 寄存器： 最快、最小和最贵的存储器类型由位于处理器内部的寄存器组成。它们用与CPU相同的材料制成，所以和CPU一样快。显然，访问它们是没有时延的。其典型的存储容量是，在32位CPU中为32x32位，而在64位CPU中为64x64位。在这两种情况下，其存储容量都小于1KB。典型情况下，一个处理器包含多个寄存器，某些处理器包含上百个寄存器。

- 高速缓存，它多数由硬件控制。

- 主存：这是存储器系统的主力。主存通常称为随机访问存储器(Random Access Memory，RAM），内存是计算机中主要的内部内部存储器系统。内存中的每个单元位置都有唯一的地址对应，而且大多数机器指令会访问一个或多个内存地址。内存通常是高速的、容量较小的高速缓存的扩展。

- 磁盘：磁盘同RAM相比，成本降低了，但是随机访问数据时间也慢了。其低速的原因是因为磁盘是一种机械装置。一个磁盘中有一个或多个金属盘片，他们以一定的速度旋转，从边缘开始有一个机械臂悬横在盘面上，这类似于老式播放塑料唱片的唱片机。

    

    ![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/changpianji.jpg?raw=true)

    有时，还有一些实际上不是磁盘的磁盘，比如固态硬盘（Solid State Disk，SSD）。固态硬盘并没有可以移动的部分，外形也不像唱片那样，并且数据是存储在存储器（闪存）中的。与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭时也不会丢失的数据。  
    
    这里要说一下闪存(flash memory)，闪存是一种基于硅芯片的存储介质，可以用电写入或擦除。在便捷式电子设备中，闪存通常作为存储媒介。闪存是数码相机中的胶卷。是便捷式音乐播放器的磁盘。这仅仅是闪存用途的两项。闪存在速度上介于RAM和磁盘之间。另外，与磁盘存储器不同的是，如果闪存擦除次数过多，就被磨损了。
    
    那闪存和固态硬盘有什么区别？固态硬盘也是将数据存储在闪存中。在存储行业中使用的最简单的类比之一是闪存就像鸡蛋，而SSD硬盘就像煎蛋卷一样。煎蛋卷主要是由鸡蛋制作的，而SSD硬盘主要由闪存制成的。





## 内存



内存包括主存(内存条,基于DRAM(动态RAM))与高速缓存(Cache,基于SRAM(静态RAM，静态RAM速度很快但是成本很高，所以用于在CPU内部充当缓冲))两部分。可能是由于Cache相较内存条容量很小，毕竟内存容量只计内存条大小，加上重要性也不及内存条，一般人或许不知道Cache,所以就忽略了高速缓存Cache，直接将主存--内存条等同了内存吧。计算器内存条采用的是DRAM(动态随机存储器)，即计算机的主存。通常所说的内存容量即指内存条DRAM的大小。

高速缓冲存储器Cache主要是为了解决CPU和主存速度不匹配而设计的。Cache一般由SRAM(静态随机存储器)芯片实现，它的存取速度接近CPU，快于DRAM，存储容量小于DRAM。它比主存的优先级高，CPU存取信息时优先访问Cache，找不到的话再去主存DRAM中找，同时把信息周围的数据块从主存复制到Cache中。 现代计算机系统基本都采用Cache-主存-辅存(即外存储器)三级存储系统。其中CPU可直接访问Cache和主存，辅存则通过主存与CPU交换信息。



![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/memory_type.png?raw=true)



### 主存的分类

- RAM(Random-access memory) 

    随机存取存储器，一般使用动态半导体存储器件（DRAM），对于CPU来说，RAM是主要存放数据和程序的地方，所以也叫做“主存”。

- ROM(Read-Only Memory)

    只读存储器，出厂时其内容由厂家用掩膜技术写好，只可读出，但无法改写。信息已固化在存储器中，一般用于存放系统程序BIOS和用于微程序，断电也没有关系，放ROM的数据一辈子都不会变。



### 缓存

位于CPU与内存之间的临时存储器，它的容量比内存小的多但是交换速率却比内存要快得多。缓存的出现主要是为了解决CPU运算速率与内存读写速率不匹配的矛盾，缓存往往使用的是RAM，L1　Cache(一级缓存)是CPU第一层高速缓存，一般L1缓存的容量通常在32—256KB，L1分为数据Cache,指令Cache,L2　Cache(二级缓存)是CPU的第二层高速缓存，分内部和外部两种芯片，内部的芯片二级缓存运行速率与主频相同，而外部的二级缓存则只有主频的一半,缓存只是内存中少部分数据的复制品。二级缓存是比一级缓存速率更慢，容量更大的内存，主要就是做一级缓存和内存之间数据临时交换的地方用。为了适应速率更快的处理器。



![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/cpu_cache_memory.png?raw=true)



缓存基本上都是采用SRAM存储器，它是一种具有静态存取功能的存储器，不需要刷新电路即能保存它内部存储的数据。不像DRAM内存那样需要刷新电路，每隔一段时间，固定要对DRAM刷新充电一次，否则内部的数据即会消失，因此SRAM具有较高的性能，但是SRAM也有它的缺点，即它的集成度较低，相同容量的DRAM内存可以设计为较小的体积，但是SRAM却需要很大的体积，这也是不能将缓存容量做得太大的重要原因。它的特点归纳如下：优点是节能、速率快、不必配合内存刷新电路、可提高整体的工作效率，缺点是集成度低、相同的容量体积较大、而且价格较高，只能少量用于关键性系统以提高效率。



缓存的工作原理是当CPU要读取一个数据时，首先从CPU缓存中查找，找到就立即读取并送给CPU处理；没有找到，就从速率相对较慢的内存中读取并送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对整块数据的读取都从缓存中进行，不必再调用内存。正是这样的读取机制使CPU读取缓存的命中率非常高，一般把静态RAM缓存叫一级缓存，而把后来增加的动态RAM叫二级缓存。







## 系统软件和应用软件



- 系统软件是指控制和协调计算机以及外部设备，支持应用软件开发和运行的系统，是无需用户干预的各种程序的集合。主要功能是调度、监控和维护计算机系统。例如: 操作系统和一系列的基本工具(编译器、数据库管理、存储器格式化、用户身份验证、网络连接)。
- 应用软件是和系统软件相对的，是用户可以使用的各种程序设计语言，以及用各种程序设计语言编译的应用程序的集合，分为应用软件包和用户程序。例如:互联网软件、多媒体软件、协作软件等。 



## Linux系统

![](https://raw.githubusercontent.com/CharonChui/Pictures/master/linux_archi.png)



## Android系统

![](https://raw.githubusercontent.com/CharonChui/Pictures/master/android_system_2.png)



- 应用和框架：应用开发者最关心这一层及访问低层服务的API。
- Binder IPC：Binder进程间通信机制允许应用框架打破进程的界限来访问Android系统服务代码，从而允许系统的高层框架API与Android的系统服务进行交互。
- Android系统服务：框架中大部分能够调用系统服务的接口都向开发者开放，以便开发者能够使用底层的硬件和内核功能。Android系统服务分为两部分：媒体服务处理播放和录制媒体文件，系统服务处理应用所需要的系统功能。
- 硬件抽象层（HAL）：HAL提供调用核心层设备驱动的标准接口，以便上层代码不需要关心具体驱动和硬件的实现袭击，Android的HAL与标准的HAL基本一致。
- Linux内核：Linux内核已被裁剪到满足移动环境的需求。



Android在Linux内核中增加了两个提升电源管理能力的新功能： 报警和唤醒锁。

- 报警功能是在Linux内核中实现的，开发者可通过调用运行库中的报警管理器来进行操作。通过报警管理器，应用可以请求定时叫醒服务。报警管理器是内核服务，目的是让应用即使在系统休眠的情况下也能触发警告提醒。这就使得系统随时可以进入休眠状态以节省电能，即使有一个进程有需要被唤醒的服务。

- 唤醒锁也可以阻止Android系统进入休眠模式。一个应用程序占有一下唤醒锁中的一个：  
    - full_wake_lock：处理器工作，屏幕亮，键盘亮。
    - partial_wake_lock:处理器工作，屏幕关，键盘关。
    - screen_dim_wake_lock:处理工作，屏幕暗，键盘关。
    - screen_bright_wake_lock：处理器工作，屏幕亮，键盘关。

当应用要求被管理的外设保持供电时，会通过API请求对应的锁。若无唤醒锁存在，系统就会锁定并关闭设备以节省电能。



## 一个程序的执行过程

```c
#include <stdio.h>
int main(int argc, char *argv[]) {
    puts("hello world");
    return 0;
}
```



1. 用户通过命令或者图标点击等通知操作系统执行hello world程序。
2. 操作系统会去找到hello world程序的相关信息，检查其类型是否是可执行文件，并通过程序的首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。
3. 操作系统创建一个新的进程，并将hello world程序的执行文件映射到该进程结构，表示由该进程执行该hello world程序。
4. 操作系统为hello world程序设置cpu上下文环境并跳到程序开始处。
5. 执行hello world程序的第一条指令，这时候会发生缺页异常(内存中没有该程序)
6. 操作系统开始分配一页物理内存，并将前面计算出的磁盘块地址将代码从磁盘读入内存，然后继续执行hello world程序。
7. hello world程序执行puts函数(系统调用)，想要在显示器上写入字符串。
8. 操作系统找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程。
9. 控制设备的进程告诉设备的窗口系统它要显示字符串。窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储影响区。
10. 视频硬件将像素转换成显示器可接收的一组控制/数据信号。
11. 显示器解释信号，激发液晶屏。
12. 这样我们就能在屏幕上看到了"hello world"。



## Linux操作系统特点

Linux是类Unix系统，借鉴了Unix的设计并实现相关接口，但并非Unix。Linux是由Linus Torvalds于1991年创造的开源免费系统，采用GNU GPL协议保护，下面列举Linux的一些主要特点：

- Linux系统中万物皆为文件，这种抽象方便操作数据或设备，只需一套统一的系统接口open, read, write, close即可完成对文件的操作
- Linux是单内核，支持动态加载内核模块，可在运行时根据需求动态加载和卸载部分内核代码；
- Linux内核支持可抢占；
- Linux内核创建进程，采用独特的fork()系统调用，创建进程较高效；
- Linux内核并不区分进程和线程，对于内核而言，进程与线程无非是共享资源的区别，对CPU调度来说并没有显著差异。



----

- [下一篇:2.进程与线程](https://github.com/CharonChui/AndroidNote/blob/master/OperatingSystem/2.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md)






---

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 
